#### 会议室门牌实时显示信息，如果是你用原生写要多久

工作中有遇到过类似的需求，需要实时显示直播人数。

自己能想到的解决方法：

1. Ajax轮询

   ```javascript
   <script type="text/javascript">
     var getting = {
       url:'server.php',
       dataType:'json',
       success:function(res) {
       console.log(res);
     }
   };
   
   //关键在这里，Ajax定时访问服务端，不断获取数据 ，这里是1秒请求一次。
   window.setInterval(function(){$.ajax(getting)},1000);
   ```

   

2. WebSocket技术

---

#### 如果上线了出现白屏怎么办

1. 第一种，打包后文件引用路径不对，导致找不到文件报错白屏

   解决办法：修改 config 下面的 index.js 中 build 模块导出的路径。因为 index.html 里面的内容都是通过 script 标签引入的，而你的路径不对，打开肯定是空白的，先看一下默认路径

   ```javascript
   把 assetsPublicPath: '/' 改为assetsPublicPath: './'
   ```

   + <font style="color:red">**以绝对路径配置**</font>：`http://192.168.3.11:8080/static/js/app.ee5d22bbbfaa3cfe658f.js`
   + <font style="color:red">**以相对路径配置**</font>：`http://192.168.3.11:8080/dist/static/js/app.ee5d22bbbfaa3cfe658f.js`
   + 期望的是第二种

2. 第二种，路由配置成 history 打开也会是一片空白，要么删除 history模式的路由改成 hash路由，要么需要加一个覆盖所有情况的候选资源

3. 第三种，项目中使用了ES6的语法，一些浏览器不支持ES6，造成编译结果错误不能解析而造成白屏

   解决方法：

   + 安装 npm install --save-dev babel-preset-es2015
   + 安装 npm install --save-dev babel-preset-stage-3
   + 在项目根目录创建一个.babelrc文件 里面内容 最基本配置是：

   ```js
   {
       // 此项指明，转码的规则
       "presets": [
           // env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码
           ["env", {
               "modules": false
           }],
           // 下面这个是不同阶段出现的es语法，包含不同的转码插件
           "stage-2"
       ],
       // 下面这个选项是引用插件来处理代码的转换，transform-runtime用来处理全局函数和优化babel编译
       "plugins": ["transform-runtime"],
       // 下面指的是在生成的文件中，不产生注释
       "comments": false,
       // 下面这段是在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置
       "env": {
           // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development
           "test": {
               "presets": ["env", "stage-2"],
               // instanbul是一个用来测试转码后代码的工具
               "plugins": ["istanbul"]
           }
       }
   }
   ```

---

#### 全局作用域中，用const和let声明的变量不在window上，那到底在哪儿？如何去获取？

1. 在ES5中，顶层对象的属性和全局变量是等价的，var命令和function命令声明的全局变量自然也是顶层对象

   ```javascript
   var a = 12;
   function f(){};
   
   console.log(window.a) //12
   console.log(window.f) // f(){}
   ```

   

2. ES6中，var和function命令声明的全局变量，依旧是顶层对象的属性，但是let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性

   ```javascript
   let aa = 1;
   const bb = 2;
   
   console.log(window.aa); // undefined
   console.log(window.bb); // undefined
   ```

   ![](https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/Vue/var与const与let.png)

   通过图可以看出，在全局作用域中，用let和const声明的全局变量并没有在全局对象中，只是在一个块级作用域script中

3. 如何获取？

   在定义变量的块级作用域中就能获取

---

#### 有以下三个判断数组的方法，请分别介绍它们之间的区别和优劣

1. `Object.prototype.toString.call`：toString 是 Object原型上的方法，该方法默认返回对象的 [[class]]，[[class]]是一个内部属性无法直接访问，一般通过 Object.prototype.toString 方法来访问，格式为[object xxx]；这种方法对于所有类型都能判断，包括 null 和 undefined

   ```javascript
   Object.prototype.toString.call("An"); // [object String]
   Object.prototype.toString.call(1); // [object Number]
   ```

2. `instance of`：通常用来判断a是否是A的实例，表达式为 a instance of A。使用instance of只能用来判断对象类型，原始类型不可以，并且所有的对象类型都会返回true

   ```
   [] instance of Array; // true
   [] instance of Object; // true
   ```

3. `Array.isArray()`：ES6新增的方法，用于检测数组类型，可能会出现不兼容的情况，需要手动写兼容方案：

   ```javascript
   is(!Array.isArray){
        Array.isArray = function(arg){
           return Object.prototype.toString.call(arg) === '[object Array]'
       }
   }
   ```

4. `typeof`：只能判断一些基础的数据类型，对于JavaScript 中的七种数据类型，typeof判断结果如下：

   + Undefined、Null、Boolean、String、Number、Symbol、Object
   + undefined、object、boolean、string、number、symbol、object

---

#### (function(){})()与(function(){}())有什么区别

1. 传统函数是这么写的

   ```javascript
   function foo(){...}; // 定义
   foo(); // 运行解释器遇到语句是会执行的               
   ```

2. 为什么要IIFE：传统方案比较啰嗦，定义和执行分开写，并且污染全局命名空间，于是开发者想找一个方案能够解决以上问题

   ```javascript
   function foo(){...}();
   ```

   这样写是不行的，因为 `function foo(){...} `这个部分只是一个声明，对于解释器来说相当于一个字符串"function foo(){...} "，需要使用解析函数比如eval解析才能执行。所以直接把（）放在后面是错误的语法

3. 那么如何修正呢？只要把字符串声明变成表达式就可以了。转换表达式的方法有很多，最常见的就是把函数声明用一对括号包起来，于是就变成了：

   ```javascript
   (function foo(){})()
   
   // 这就等价于
   function foo(){...};
   foo();
   
   // 也等价于
   (function foo(){}())
   ```

   <font style="color:red">所以答案是没有区别</font>

4. 转变表达式的方法有很多：()，+，-，=，void等等都是运算符，都能将函数声明变成函数表达式

   ```javascript
   !function foo(){}();
   +function foo(){}();
   void function foo(){}();
   ```

   













































