### 说说你对SPA的理解

1. 定义：SPA就是单页应用，框架的主体不变，通过动态改变当前页面来与用户交互，避免了切换页面带来的频繁刷新页面
2. 优缺点：
   + 优点：
     + 用户体验好、快，内容的改变不需要加载整个页面
     + 良好的前后端分离，分工更加明确
   + 缺点：
     + 首次加载的时候会比较慢

---

 ### Vue组件之间通信的方式

1. 如何通信
   + 父子组件之间：父组件通过props传递给子组件，子组件通过$emit传递给父组件
   + 兄弟组件之间：中央时间总线eventBus，一个组件$emit触发自定义事件，另一个组件通过$on监听事件
   + 非关系组件之间：Vuex

---

### 说说Vue和React之间的区别

1. 相同点：
   + 都有组件化的思想
   + 都支持服务端渲染
   + 都有VirtualDOM
   + 都是数据驱动视图
   + 都有自己的构建工具：create-react-app、vue-cli
2. 不同点：
   + 模板语法不同：
     + Vue的Vue template，React是JSX语法
     + Vue中的循环和判断使用的是v-if和v-for，React中是使用if判断，for/map循环进行dom渲染
   + 数据的拦截方式不同
     + Vue通过Object.difineProperty来给对象添加get和set，对数据的侦听更加快捷和精确，一旦有了变化会立马去更新，React提倡开发者手动通过setState方法去实现局部刷新
     + Vue有双向绑定，而React是单向数据流
   + 组件之间通信方式不同
     + Vue通过回调函数和事件监听，React通过回调函数
   + 渲染的优化不同：
     + Vue中组件渲染采用的是默认的优化，React中可以使用shouldComponentUpdate、pureComponent、memo等进行优化
   + diff算法不同：
     + React使用diff队列保存需要更新哪些DOM，得到patch树， 再统一操作批量更新DOM。Vue使用双向指针，边对比边更新DOM

---

### Vue有哪些特性、核心特性、亮点、不同点、印象比较深的点、优点、你为什么喜欢Vue

1. Vue是数据驱动，MVVM模型：
   + Model：模型层，数据层，存储数据以及对数据的增删改查，和服务器进行交互
   + View：视图层，UI用户界面，负责将数据模型转化为UI展示，可以简单的理解为HTML页面
   + ViewModel：业务逻辑层，js，连接Model和View，是Model和View之间的桥梁
2. Vue的组件化思想：
   + 降低耦合度、维护方便、调试方便等
3. Vue强大的指令系统：
   + v-if
   + v-for
   + v-bind
   + v-on
   + v-model
4. Vue良好的生态环境：我们前端开发是一个向前进步的过程，不断探索才能得出最佳实践



---

### Vue的响应式原理中，Object.defineProperty有什么缺陷？为什么在3.0中采用了Proxy？

1. Object.defineProperty
   + 无法监测到数组下标的变化，导致通过数组下标添加元素不能实时响应
   + 劫持对象属性时，如果属性还是个对象，需要深度遍历
   + 无法监听到动态添加的属性的变化
2. Proxy
   + 可以劫持整个对象返回一个新的对象，不需要深度遍历监听
     + var newProxy = new Proxy(target,handler);监听整个对象
     +  Object.defineProperty(target, key, sharedPropertyDefinition)
   + 可以代理数组即数组变化也能监听，代理动态添加的属性

---

### v-if和v-for的区别是什么

v-for比v-if优先级高，这意味着v-if将被重复运用到每个v-for循环中，每次渲染都会进行条件判断，这样会带来性能的浪费，这就是为什么不建议将v-for和v-if放在同一个元素上



建议将v-if和v-for放在不同的标签上，这样v-if会先进行判断再决定是否进行列表渲染

---

### v-if和v-show的区别

1. 区别：
   + v-if是通过控制dom节点的存在与否来控制元素的显示与隐藏
   + v-show是通过设置DOM元素的display样式，block为显示，none为隐藏。none的条件下，dom元素依旧还是存在的
2. 如何选用：如果需要频繁的切换显示与隐藏，使用v-show比较好；如果在运行时，条件很少改变使用v-if较好
   + v-if判断是否加载，可以减轻服务器的压力
   + v-show调整DOM元素的css display属性 

---

### 从后台获取的数据层级比较多，导致修改Vue数据DOM没有更新

解决方法：

1. 首先从后端数据结构优化，接口拆分等等。合理的数据结构，后端易查易存储，前端易读取易展示。
2. 如果后端数据结构无法改变：
   + this.$set
   + this.$forceUpdate

---

### v-for获取列表的前n个数据、中间范围的数据、末尾n条数据的方法

1. 前n个数据：item.slice(0,n)或者v-if="index<n"
2. 中间范围的数据：slice(n,2n+1)
3. 末尾n条数据：slice(item.length-n,item.length)

---

### Ajax请求是放在created里面好还是mounted里面好

放在created里面好，在页面渲染完成之前就把数据加载出来，

如果放在mounted里面，有可能数据请求还没回来，页面不知道要渲染什么数据，会直接把差值绑定的模板{{}}渲染出来，当拿到数据再去渲染会出现闪屏

---

### computed和method的区别

computed带有缓存，而method不带缓存

---

### 为什么Vue的data要写成返回对象的函数

当我们新建一个组件的时候，data必须声明为返回一个对象的函数，因为该组件很有可能被用来创建多个实例，即多个地方被复用。

+ 如果data是一个单纯的对象，则所有的实例将共享同一个数据对象

+ 如果data是一个函数，我们通过调用函数，每次创建一个实例之后，都会返回一个全新的副本对象

  ```javascript
  // 返回一个对象，则所有重用的实例中的data都是同一个对象
  var data = {
      x：1
  }
  var vm1 = {
      data:data
  }
  var vm2 = {
      data:data
  }
  vm1.data===vm2.data; // true指向同一个对象
  
  // 函数方式，所有重用的实例中的data均返回新的副本对象
  var func = function(){
    return {
      x:1
    }
  }
  var vm3 = {
    data: func
  }
  var vm4 = {
    data: func
  }
  vm3.data === vm4.data; // false 指向不同的对象
  ```

---

### Vue的修饰符有哪些，都有什么作用？

1. 表单修饰符：
   + v-model.lazy：我们输完所有的东西，光标离开才会更新视图
   + v-model.trim：过滤输入的字符串中的空格
   + v-model.number：限制输入的只能是数字
2. 事件修饰符：
   + @click.stop：相当于event.stopPropagation（）阻止事件冒泡
   + @submit.prevent：阻止事件的默认行为，相当于event.preventDefault
   + @click.self：当事件是从事件绑定的元素本身触发时才触发回调
   + @click.once：绑定了事件之后只能触发一次，第二次就不会被触发
   + @click.capture：多用于事件冒泡时控制触发顺序。事件冒泡的完整机制是：捕获阶段 -> 目标阶段 -> 冒泡阶段，当我们加上了这个修饰符之后，事件触发从包含这个元素的顶层开始往下触发
   + @click.native：给自定义的组件绑定点击事件，将Vue组件的标签转化为普通HTML才能触发我们绑定的这个事件

3. 鼠标按键修饰符：

   + .left：左键
   + .right：右键
   + .middle：中键

4. 键值修饰符

   + @keyup.keyCode

5. v-bind修饰符.sync：当一个子组件改变了一个prop的值时，这个变化也会同步到父组件中所绑定，即可以用来做props的双向绑定

   ```javascript
   // 通常做法，父组件监听子组件emit过来的事件
   // 父组件
   <comp :mesage='bar' @update:myMessage="func" />
    func(e){
      this.bar = e   
   }
   // 子组件
   func2(){
     this.$emit('updateM// 父组件
   <comp :myMessage.sync="bar"></comp>
   // 子组件
   this.$emit('update:myMessage',params)
   
   // 使用.sync的做法 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值
   // 父组件
   <comp :myMessage.sync="bar"></comp>
   // 子组件
   this.$emit('update:myMessage',params)必须这么写
   ```

   .sync是一个语法糖，实际上会被扩展为自动更新父组件属性的v-on监听器，当子组件需要更新foo的值时，它需要显示地触发一个更新事件：

   ```javascript
   <comp :foo.sync="bar" />
   // 扩展为
   <comp :foo="bar" @update:foo="val" />    
   ```

---

### Vue中更新组件的方式有哪些

1. 不好的方法：使用v-if进行销毁和重新渲染
2. 较好的方法：使用Vue内置的forUpdate方法让实例重新渲染
3. 最好的方法：给组件设置key，更改key相当于重新渲染一个组件

---

### vue-router中query和params的区别

1. $router和$route的区别：

   + $router是VueRouter的实例，想要导航到不同的url，可以使用$router.push方法
   + $route为当前router跳转的对象，里面可以获取name、path、query、params等

2. params和query的区别：

   + 传参形式的区别：

     ```javascript
     // params
     this.$router.push({
         name:"xxx",
         params:{
            id:id 
         }
     })
     // 接收
     this.$route.params.id
     
     // query
     this.$router.push({
         name:"xxx",
         query:{
            id:id 
         }
     })
     // 接收
     this.$route.query.id
     ```

     

   + 传参结果的区别：

     + query生成的url为/xxx?id=id，params生成的url为xxx/id
     + params方式要注意定义路由信息，比如：path:'xx/:id'，这样才能携带参数跳转，否则url不会发生变化并且再次刷新页面参数会读取不到

---

### Vue中组件和插件有什么不同

1. 区别：

   + 组件就是把整个应用拆分成不同的模块，往往一个模块就是一个组件，其中细分各种功能组件

   + 插件通常是一些全局的功能，比如全局的方法、API等等

2. 自己有写过插件吗

   + 之前做过一个点餐APP的项目，其中有个功能，点击餐品，向上弹出详情介绍的功能，这个功能在整个系统中很常见，如果用组件的话到处引用感觉不是很方便，就做成了插件
   + Vue的插件注册流程

---

### 在Vue中传递$event，使用e.target和e.currentTarget有什么不同？

1. e.target：指向事件发生的元素
2. e.currentTarget：指向事件所绑定的元素

---

### 为什么data、props、methods不能同名

因为它们最终都会被挂载到Vue实例上，变成this.xxx，所以不能同名。并且源码中也有是否同名的逻辑判断

---

### Vue的父组件和子组件生命周期钩子的执行顺序是什么？

1. 加载渲染过程：父beforeCreate -> 父created -> 父beforeMounted -> 父mounted -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted
2. 子组件更新过程：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
3. 父组件更新过程：父beforeUpdate -> 父updated
4. 销毁过程：父beforeDestory -> 子beforeDestory -> 子destoryed -> 父destoryed

---

### Vue渲染大量数据时怎么优化？

1. 如果一次性传入大量数据
   + 跟后端沟通是否可以改变数据结构或者增加接口
   + 增加加载动画提升用户体验
   + 避免浏览器处理大量的dom
   + 服务端渲染
   + 懒加载
2. 如果并非一次性传入大量数据，而是分段加载，但是次数很多
   + 异步渲染组件
   + 使用v-if最多显示一屏，避免出现大量的dom节点
   + 分页

---

### 什么是异步组件

1. 定义：异步组件就是通过import()函数引入，什么时候使用就什么时候加载

2. Vue中组件的三种引入方式：

   + 传统引入方式，即最常见的引入方式

     ```javascript
     import LeftLine from "..."
     components: {
        LeftLine
     }
     ```

   + import - 异步方式

     ```javascript
     components:{
       LeftLine:()=>import("@/views/components/xxx")
     }
     ```

   + 按需引入- 异步方式，这种方式和import引入的方式差不多

     ```
     components:{
       LeftLine:resolve=>require(["@/views/components/xxx"],resolve)
     }
     ```

     

---

### SPA单页面应用首屏加载比较慢应该如何解决

1. 什么是首屏加载时间：浏览器从响应用户输入网址到首屏内容渲染完成的时间
2. 造成首屏加载慢的原因：
   + 图片太大没有压缩：一般大图控制在300k以内，小图控制在50k以内，让UI压缩好素材再给到我们
   + 项目中使用了许多插件也会被打包，比如轮播、倒计时等等
   + 其他文件，比如图标、字体文件等等也会被打包
   + 文件过于庞大，导致首页加载js的时候堵塞了
3. 如何解决：
   + 把插件资源、图片、文件等放在cdn里面加速，然后项目里使用cdn的在线链接
   + 路由懒加载，在配置路由文件的时候改成懒加载的方式
   + 如果用到UI框架，UI框架的组件按需引入
   + 避免重复打包，文件A中使用了c.js，文件B也使用了c.js就会造成重复打包，在webpack的CommonChunkPlugin中修改
   + 服务端渲染技术

---

### Vue中的watch和created哪个先执行？

1. 结论：

   + watch中的`immediate`为true会让监听在初始值声明的时候就去执行，否则就是created先执行

2. 原因：

   + 在Vue生成实例初始化时，源码是这样的：

     ```javascript
     //...
     initState(vm);
     initProvide(vm);
     callHook(vm,'created')
     //...
     ```

     `initState`里面包含了一段关于`watch`初始化的逻辑：

     ```javascript
     if(options.immediate){
        cb.call(vm,watcher.value)
     }
     ```

     所以，watch如果声明了immediate属性为true就会在created生命周期钩子之前执行，否则就是created先执行

---

### preload和prefetch的区别

















































































